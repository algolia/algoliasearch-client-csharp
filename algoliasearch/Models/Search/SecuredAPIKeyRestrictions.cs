//
// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
//
using System;
using System.Text;
using System.Linq;
using System.Text.Json.Serialization;
using System.Collections.Generic;
using Algolia.Search.Serializer;
using System.Text.Json;

namespace Algolia.Search.Models.Search;

/// <summary>
/// SecuredAPIKeyRestrictions
/// </summary>
public partial class SecuredAPIKeyRestrictions
{
  /// <summary>
  /// Initializes a new instance of the SecuredAPIKeyRestrictions class.
  /// </summary>
  public SecuredAPIKeyRestrictions()
  {
  }

  /// <summary>
  /// Gets or Sets SearchParams
  /// </summary>
  [JsonPropertyName("searchParams")]
  public SearchParamsObject SearchParams { get; set; }

  /// <summary>
  /// Filters that apply to every search made with the secured API key. You can add extra filters at search time with the filters query parameter. For example, if you set the filter group:admin on your generated API key, and you add groups:press OR groups:visitors with the filters query parameter, your final search filter is equivalent to groups:admin AND (groups:press OR groups:visitors). 
  /// </summary>
  /// <value>Filters that apply to every search made with the secured API key. You can add extra filters at search time with the filters query parameter. For example, if you set the filter group:admin on your generated API key, and you add groups:press OR groups:visitors with the filters query parameter, your final search filter is equivalent to groups:admin AND (groups:press OR groups:visitors). </value>
  [JsonPropertyName("filters")]
  public string Filters { get; set; }

  /// <summary>
  /// Unix timestamp used to set the expiration date of the API key.
  /// </summary>
  /// <value>Unix timestamp used to set the expiration date of the API key.</value>
  [JsonPropertyName("validUntil")]
  public long? ValidUntil { get; set; }

  /// <summary>
  /// Index names that can be queried.
  /// </summary>
  /// <value>Index names that can be queried.</value>
  [JsonPropertyName("restrictIndices")]
  public List<string> RestrictIndices { get; set; }

  /// <summary>
  /// IPv4 network allowed to use the generated key. Use this to protect against API key leaking and reuse. You can only provide a single source, but you can specify a range of IPs (for example, 192.168.1.0/24). 
  /// </summary>
  /// <value>IPv4 network allowed to use the generated key. Use this to protect against API key leaking and reuse. You can only provide a single source, but you can specify a range of IPs (for example, 192.168.1.0/24). </value>
  [JsonPropertyName("restrictSources")]
  public string RestrictSources { get; set; }

  /// <summary>
  /// Unique user IP address. This can be useful when you want to impose a rate limit on specific users. By default, rate limits are set based on the IP address. This can become an issue when several users search from the same IP address. To avoid this, you can set a unique userToken for each user when generating their API key. This lets you restrict each user to a maximum number of API calls per hour, even if they share their IP with another user. Specifying the userToken in a secured API key is also a good security practice as it ensures users don't change it. Many features like Analytics, Personalization, and Dynamic Re-ranking rely on the authenticity of user identifiers. Setting the userToken at the API key level ensures that downstream services work as expected and prevents abuse. 
  /// </summary>
  /// <value>Unique user IP address. This can be useful when you want to impose a rate limit on specific users. By default, rate limits are set based on the IP address. This can become an issue when several users search from the same IP address. To avoid this, you can set a unique userToken for each user when generating their API key. This lets you restrict each user to a maximum number of API calls per hour, even if they share their IP with another user. Specifying the userToken in a secured API key is also a good security practice as it ensures users don't change it. Many features like Analytics, Personalization, and Dynamic Re-ranking rely on the authenticity of user identifiers. Setting the userToken at the API key level ensures that downstream services work as expected and prevents abuse. </value>
  [JsonPropertyName("userToken")]
  public string UserToken { get; set; }

  /// <summary>
  /// Returns the string presentation of the object
  /// </summary>
  /// <returns>String presentation of the object</returns>
  public override string ToString()
  {
    StringBuilder sb = new StringBuilder();
    sb.Append("class SecuredAPIKeyRestrictions {\n");
    sb.Append("  SearchParams: ").Append(SearchParams).Append("\n");
    sb.Append("  Filters: ").Append(Filters).Append("\n");
    sb.Append("  ValidUntil: ").Append(ValidUntil).Append("\n");
    sb.Append("  RestrictIndices: ").Append(RestrictIndices).Append("\n");
    sb.Append("  RestrictSources: ").Append(RestrictSources).Append("\n");
    sb.Append("  UserToken: ").Append(UserToken).Append("\n");
    sb.Append("}\n");
    return sb.ToString();
  }

  /// <summary>
  /// Returns the JSON string presentation of the object
  /// </summary>
  /// <returns>JSON string presentation of the object</returns>
  public virtual string ToJson()
  {
    return JsonSerializer.Serialize(this, JsonConfig.Options);
  }

  /// <summary>
  /// Returns true if objects are equal
  /// </summary>
  /// <param name="obj">Object to be compared</param>
  /// <returns>Boolean</returns>
  public override bool Equals(object obj)
  {
    if (obj is not SecuredAPIKeyRestrictions input)
    {
      return false;
    }

    return
        (SearchParams == input.SearchParams || (SearchParams != null && SearchParams.Equals(input.SearchParams))) &&
        (Filters == input.Filters || (Filters != null && Filters.Equals(input.Filters))) &&
        (ValidUntil == input.ValidUntil || ValidUntil.Equals(input.ValidUntil)) &&
        (RestrictIndices == input.RestrictIndices || RestrictIndices != null && input.RestrictIndices != null && RestrictIndices.SequenceEqual(input.RestrictIndices)) &&
        (RestrictSources == input.RestrictSources || (RestrictSources != null && RestrictSources.Equals(input.RestrictSources))) &&
        (UserToken == input.UserToken || (UserToken != null && UserToken.Equals(input.UserToken)));
  }

  /// <summary>
  /// Gets the hash code
  /// </summary>
  /// <returns>Hash code</returns>
  public override int GetHashCode()
  {
    unchecked // Overflow is fine, just wrap
    {
      int hashCode = 41;
      if (SearchParams != null)
      {
        hashCode = (hashCode * 59) + SearchParams.GetHashCode();
      }
      if (Filters != null)
      {
        hashCode = (hashCode * 59) + Filters.GetHashCode();
      }
      hashCode = (hashCode * 59) + ValidUntil.GetHashCode();
      if (RestrictIndices != null)
      {
        hashCode = (hashCode * 59) + RestrictIndices.GetHashCode();
      }
      if (RestrictSources != null)
      {
        hashCode = (hashCode * 59) + RestrictSources.GetHashCode();
      }
      if (UserToken != null)
      {
        hashCode = (hashCode * 59) + UserToken.GetHashCode();
      }
      return hashCode;
    }
  }

}

