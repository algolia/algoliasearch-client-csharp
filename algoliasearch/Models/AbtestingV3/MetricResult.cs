//
// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Algolia.Search.Serializer;

namespace Algolia.Search.Models.AbtestingV3;

/// <summary>
/// MetricResult
/// </summary>
public partial class MetricResult
{
  /// <summary>
  /// Initializes a new instance of the MetricResult class.
  /// </summary>
  [JsonConstructor]
  public MetricResult() { }

  /// <summary>
  /// Initializes a new instance of the MetricResult class.
  /// </summary>
  /// <param name="name">name (required).</param>
  /// <param name="updatedAt">Date and time when the metric was last updated, in RFC 3339 format. (required).</param>
  /// <param name="value">value (required).</param>
  /// <param name="pValue">PValue for the first variant (control) will always be 0. For the other variants, pValue is calculated for the current variant based on the control. (required).</param>
  public MetricResult(string name, string updatedAt, double value, double pValue)
  {
    Name = name ?? throw new ArgumentNullException(nameof(name));
    UpdatedAt = updatedAt ?? throw new ArgumentNullException(nameof(updatedAt));
    Value = value;
    PValue = pValue;
  }

  /// <summary>
  /// Gets or Sets Name
  /// </summary>
  [JsonPropertyName("name")]
  public string Name { get; set; }

  /// <summary>
  /// Date and time when the metric was last updated, in RFC 3339 format.
  /// </summary>
  /// <value>Date and time when the metric was last updated, in RFC 3339 format.</value>
  [JsonPropertyName("updatedAt")]
  public string UpdatedAt { get; set; }

  /// <summary>
  /// Gets or Sets Value
  /// </summary>
  [JsonPropertyName("value")]
  public double Value { get; set; }

  /// <summary>
  /// The upper bound of the 95% confidence interval for the metric value. The confidence interval is calculated using either the relative ratio or relative difference between the metric values for the control and the variant. Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative difference is used for continuous metrics (e.g., revenue).
  /// </summary>
  /// <value>The upper bound of the 95% confidence interval for the metric value. The confidence interval is calculated using either the relative ratio or relative difference between the metric values for the control and the variant. Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative difference is used for continuous metrics (e.g., revenue). </value>
  [JsonPropertyName("valueCIHigh")]
  public double? ValueCIHigh { get; set; }

  /// <summary>
  /// The lower bound of the 95% confidence interval for the metric value. The confidence interval is calculated using either the relative ratio or relative difference between the metric values for the control and the variant. Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative difference is used for continuous metrics (e.g., revenue).
  /// </summary>
  /// <value>The lower bound of the 95% confidence interval for the metric value. The confidence interval is calculated using either the relative ratio or relative difference between the metric values for the control and the variant. Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative difference is used for continuous metrics (e.g., revenue). </value>
  [JsonPropertyName("valueCILow")]
  public double? ValueCILow { get; set; }

  /// <summary>
  /// PValue for the first variant (control) will always be 0. For the other variants, pValue is calculated for the current variant based on the control.
  /// </summary>
  /// <value>PValue for the first variant (control) will always be 0. For the other variants, pValue is calculated for the current variant based on the control.</value>
  [JsonPropertyName("pValue")]
  public double PValue { get; set; }

  /// <summary>
  /// Dimension defined during test creation.
  /// </summary>
  /// <value>Dimension defined during test creation.</value>
  [JsonPropertyName("dimension")]
  public string Dimension { get; set; }

  /// <summary>
  /// Gets or Sets Metadata
  /// </summary>
  [JsonPropertyName("metadata")]
  public MetricMetadata Metadata { get; set; }

  /// <summary>
  /// The value that was computed during error correction. It is used to determine significance of the metric pValue. The critical value is calculated using Bonferroni or Benjamini-Hochberg corrections, based on the given configuration during the A/B test creation.
  /// </summary>
  /// <value>The value that was computed during error correction. It is used to determine significance of the metric pValue. The critical value is calculated using Bonferroni or Benjamini-Hochberg corrections, based on the given configuration during the A/B test creation. </value>
  [JsonPropertyName("criticalValue")]
  public double? CriticalValue { get; set; }

  /// <summary>
  /// Whether the pValue is significant or not based on the critical value and the error correction algorithm used.
  /// </summary>
  /// <value>Whether the pValue is significant or not based on the critical value and the error correction algorithm used. </value>
  [JsonPropertyName("significant")]
  public bool? Significant { get; set; }

  /// <summary>
  /// Returns the string presentation of the object
  /// </summary>
  /// <returns>String presentation of the object</returns>
  public override string ToString()
  {
    StringBuilder sb = new StringBuilder();
    sb.Append("class MetricResult {\n");
    sb.Append("  Name: ").Append(Name).Append("\n");
    sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
    sb.Append("  Value: ").Append(Value).Append("\n");
    sb.Append("  ValueCIHigh: ").Append(ValueCIHigh).Append("\n");
    sb.Append("  ValueCILow: ").Append(ValueCILow).Append("\n");
    sb.Append("  PValue: ").Append(PValue).Append("\n");
    sb.Append("  Dimension: ").Append(Dimension).Append("\n");
    sb.Append("  Metadata: ").Append(Metadata).Append("\n");
    sb.Append("  CriticalValue: ").Append(CriticalValue).Append("\n");
    sb.Append("  Significant: ").Append(Significant).Append("\n");
    sb.Append("}\n");
    return sb.ToString();
  }

  /// <summary>
  /// Returns the JSON string presentation of the object
  /// </summary>
  /// <returns>JSON string presentation of the object</returns>
  public virtual string ToJson()
  {
    return JsonSerializer.Serialize(this, JsonConfig.Options);
  }

  /// <summary>
  /// Returns true if objects are equal
  /// </summary>
  /// <param name="obj">Object to be compared</param>
  /// <returns>Boolean</returns>
  public override bool Equals(object obj)
  {
    if (obj is not MetricResult input)
    {
      return false;
    }

    return (Name == input.Name || (Name != null && Name.Equals(input.Name)))
      && (UpdatedAt == input.UpdatedAt || (UpdatedAt != null && UpdatedAt.Equals(input.UpdatedAt)))
      && (Value == input.Value || Value.Equals(input.Value))
      && (ValueCIHigh == input.ValueCIHigh || ValueCIHigh.Equals(input.ValueCIHigh))
      && (ValueCILow == input.ValueCILow || ValueCILow.Equals(input.ValueCILow))
      && (PValue == input.PValue || PValue.Equals(input.PValue))
      && (Dimension == input.Dimension || (Dimension != null && Dimension.Equals(input.Dimension)))
      && (Metadata == input.Metadata || (Metadata != null && Metadata.Equals(input.Metadata)))
      && (CriticalValue == input.CriticalValue || CriticalValue.Equals(input.CriticalValue))
      && (Significant == input.Significant || Significant.Equals(input.Significant));
  }

  /// <summary>
  /// Gets the hash code
  /// </summary>
  /// <returns>Hash code</returns>
  public override int GetHashCode()
  {
    unchecked // Overflow is fine, just wrap
    {
      int hashCode = 41;
      if (Name != null)
      {
        hashCode = (hashCode * 59) + Name.GetHashCode();
      }
      if (UpdatedAt != null)
      {
        hashCode = (hashCode * 59) + UpdatedAt.GetHashCode();
      }
      hashCode = (hashCode * 59) + Value.GetHashCode();
      hashCode = (hashCode * 59) + ValueCIHigh.GetHashCode();
      hashCode = (hashCode * 59) + ValueCILow.GetHashCode();
      hashCode = (hashCode * 59) + PValue.GetHashCode();
      if (Dimension != null)
      {
        hashCode = (hashCode * 59) + Dimension.GetHashCode();
      }
      if (Metadata != null)
      {
        hashCode = (hashCode * 59) + Metadata.GetHashCode();
      }
      hashCode = (hashCode * 59) + CriticalValue.GetHashCode();
      hashCode = (hashCode * 59) + Significant.GetHashCode();
      return hashCode;
    }
  }
}
