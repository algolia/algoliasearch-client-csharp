//
// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Algolia.Search.Serializer;

namespace Algolia.Search.Models.Composition;

/// <summary>
/// Composition
/// </summary>
public partial class Composition
{
  /// <summary>
  /// Initializes a new instance of the Composition class.
  /// </summary>
  [JsonConstructor]
  public Composition() { }

  /// <summary>
  /// Initializes a new instance of the Composition class.
  /// </summary>
  /// <param name="objectID">Composition unique identifier. (required).</param>
  /// <param name="name">Composition name. (required).</param>
  /// <param name="behavior">behavior (required).</param>
  public Composition(string objectID, string name, CompositionBehavior behavior)
  {
    ObjectID = objectID ?? throw new ArgumentNullException(nameof(objectID));
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Behavior = behavior ?? throw new ArgumentNullException(nameof(behavior));
  }

  /// <summary>
  /// Composition unique identifier.
  /// </summary>
  /// <value>Composition unique identifier.</value>
  [JsonPropertyName("objectID")]
  public string ObjectID { get; set; }

  /// <summary>
  /// Composition name.
  /// </summary>
  /// <value>Composition name.</value>
  [JsonPropertyName("name")]
  public string Name { get; set; }

  /// <summary>
  /// Composition description.
  /// </summary>
  /// <value>Composition description.</value>
  [JsonPropertyName("description")]
  public string Description { get; set; }

  /// <summary>
  /// Gets or Sets Behavior
  /// </summary>
  [JsonPropertyName("behavior")]
  public CompositionBehavior Behavior { get; set; }

  /// <summary>
  /// A mapping of sorting labels to the indices (or replicas) that implement those sorting rules. The sorting indices MUST be related to the associated main targeted index in the composition. Each key is the label your frontend sends at runtime (for example, \"Price (asc)\"), and each value is the name of the index that should be queried when that label is selected.  When a request includes a \"sortBy\" parameter, the platform looks up the corresponding index in this mapping and uses it to execute the query. The main targeted index is replaced with the sorting strategy index it is mapped to.  Up to 20 sorting strategies can be defined.
  /// </summary>
  /// <value>A mapping of sorting labels to the indices (or replicas) that implement those sorting rules. The sorting indices MUST be related to the associated main targeted index in the composition. Each key is the label your frontend sends at runtime (for example, \"Price (asc)\"), and each value is the name of the index that should be queried when that label is selected.  When a request includes a \"sortBy\" parameter, the platform looks up the corresponding index in this mapping and uses it to execute the query. The main targeted index is replaced with the sorting strategy index it is mapped to.  Up to 20 sorting strategies can be defined. </value>
  [JsonPropertyName("sortingStrategy")]
  public Dictionary<string, string> SortingStrategy { get; set; }

  /// <summary>
  /// Returns the string presentation of the object
  /// </summary>
  /// <returns>String presentation of the object</returns>
  public override string ToString()
  {
    StringBuilder sb = new StringBuilder();
    sb.Append("class Composition {\n");
    sb.Append("  ObjectID: ").Append(ObjectID).Append("\n");
    sb.Append("  Name: ").Append(Name).Append("\n");
    sb.Append("  Description: ").Append(Description).Append("\n");
    sb.Append("  Behavior: ").Append(Behavior).Append("\n");
    sb.Append("  SortingStrategy: ").Append(SortingStrategy).Append("\n");
    sb.Append("}\n");
    return sb.ToString();
  }

  /// <summary>
  /// Returns the JSON string presentation of the object
  /// </summary>
  /// <returns>JSON string presentation of the object</returns>
  public virtual string ToJson()
  {
    return JsonSerializer.Serialize(this, JsonConfig.Options);
  }

  /// <summary>
  /// Returns true if objects are equal
  /// </summary>
  /// <param name="obj">Object to be compared</param>
  /// <returns>Boolean</returns>
  public override bool Equals(object obj)
  {
    if (obj is not Composition input)
    {
      return false;
    }

    return (ObjectID == input.ObjectID || (ObjectID != null && ObjectID.Equals(input.ObjectID)))
      && (Name == input.Name || (Name != null && Name.Equals(input.Name)))
      && (
        Description == input.Description
        || (Description != null && Description.Equals(input.Description))
      )
      && (Behavior == input.Behavior || (Behavior != null && Behavior.Equals(input.Behavior)))
      && (
        SortingStrategy == input.SortingStrategy
        || SortingStrategy != null
          && input.SortingStrategy != null
          && SortingStrategy.SequenceEqual(input.SortingStrategy)
      );
  }

  /// <summary>
  /// Gets the hash code
  /// </summary>
  /// <returns>Hash code</returns>
  public override int GetHashCode()
  {
    unchecked // Overflow is fine, just wrap
    {
      int hashCode = 41;
      if (ObjectID != null)
      {
        hashCode = (hashCode * 59) + ObjectID.GetHashCode();
      }
      if (Name != null)
      {
        hashCode = (hashCode * 59) + Name.GetHashCode();
      }
      if (Description != null)
      {
        hashCode = (hashCode * 59) + Description.GetHashCode();
      }
      if (Behavior != null)
      {
        hashCode = (hashCode * 59) + Behavior.GetHashCode();
      }
      if (SortingStrategy != null)
      {
        hashCode = (hashCode * 59) + SortingStrategy.GetHashCode();
      }
      return hashCode;
    }
  }
}
